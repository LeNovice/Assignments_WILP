# -*- coding: utf-8 -*-
"""DSAD_assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SWXdcDGKQkirpQs9jPgye32C-jjmlgCm
"""

# This is the DSAD Assignment 1 â€“ PS11 - [Laptop Rentals]

"""
Program that returns the minimum number of laptops that the
school needs to rent such that all students will always have
access to a laptop when they need one

Returns minimum number of laptops required to be rented.
We will first get the requirements of a laptop as the time
intervals during which students need them.

For example if [x,y] is the time interval it means that a student
will borrow a laptop at time 'x' and return it at time 'y'.

Note: If a student returns a laptop at time 'y' then as per the
problem statement immediately this laptop becomes available and
another student can borrow it at the same time 'y'.

We will add all the borrowing times of students in one list.
Similarly we will add all the returning times of students in
another list.

We will sort the two lists using HeapSort algorithm!

The idea here is that once the borrow and return times are in
sorted order we will track down the number of laptops at any
time by tacking the laptops that have been borrowed but not
yet returned.

For example let's say the time intervals provided are:
T[x, y] = [0, 2], [1, 5], [4, 6], [0, 3]

Sorted list of borrowing times: [0, 0, 1, 4]
Sorted list of returning times: [2, 3, 5, 6]

Total laptops given to students at any time is the difference
between total laptops borrowed and total laptops returned
by that time.

Time	Borrowed/Returned	Laptops needed at this time
0			Borrowed				1
0			Borrowed				2
1			Borrowed				3
2			Returned				2
3			Returned				1
4			Borrowed				2
5			Returned				1
6			Returned				0

Hence, minimum laptops required is the maximum of number of
laptops needed at any particular point of time.

In above example minimum laptops required would be 3.

"""

import sys
class Entry:

	def __init__(self, borrow_time, return_time):
		self.b_time = borrow_time
		self.r_time = return_time

class MaxHeap:

	def __init__(self, maxsize):
		self.maxsize = maxsize
		self.size = 0   #1 because the first entry is already put to 1(ignore)
		self.Heap = []  #Initialize empty array instead#[Entry(0,0)] * (self.maxsize + 1)
		self.Heap.append(Entry(1*sys.maxsize,1*sys.maxsize))
		self.FRONT = 1

	# Function to return the position of
	# parent for the node currently
	# at pos
	def parent(self, pos):

		return pos // 2

	# Function to return the position of
	# the left child for the node currently
	# at pos
	def leftChild(self, pos):

		return 2 * pos

	# Function to return the position of
	# the right child for the node currently
	# at pos
	def rightChild(self, pos):

		return (2 * pos) + 1

	# Function that returns true if the passed
	# node is a leaf node
	def isLeaf(self, pos):

		if pos >= (self.size//2) and pos <= self.size:
			return True
		return False

	# Function to swap two nodes of the heap
	def swap(self, fpos, spos):

		self.Heap[fpos], self.Heap[spos] = (self.Heap[spos],self.Heap[fpos])

	# Function to heapify the node at pos (motivation from DSA slides)
	def maxHeapify(self, pos):
                #maxHeapify works from the root node and goes down
                #Thus to keep uniformity, we need to start at the lowest depth of tree, Use max Heapify on lowest parents
                #Then start slowly climbing towards root
                #Following function is the top down approach
                if (self.leftChild(pos) < self.size):
                        if(self.Heap[self.leftChild(pos)].b_time > self.Heap[pos].b_time):
                                largest = self.leftChild(pos)
                        elif(self.Heap[self.leftChild(pos)].b_time == self.Heap[pos].b_time):
                                if(self.Heap[self.leftChild(pos)].r_time > self.Heap[pos].r_time):
                                        largest = self.leftChild(pos)
                                else:
                                        largest = pos
                        else:
                                largest = pos
                else:
                        largest = pos
                if (self.rightChild(pos) < self.size):
                        if (self.Heap[self.rightChild(pos)].b_time > self.Heap[largest].b_time):
                                largest = self.rightChild(pos)
                        elif(self.Heap[self.rightChild(pos)].b_time == self.Heap[largest].b_time):
                                if(self.Heap[self.rightChild(pos)].r_time > self.Heap[largest].r_time):
                                        largest = self.rightChild(pos)
                if largest != pos:
                        self.Heap[pos], self.Heap[largest] = self.Heap[largest], self.Heap[pos]
                        self.maxHeapify(largest)

	def build_max_heap(self):
		for i in reversed(range(1, (self.size//2) + 1)):
			self.maxHeapify(i)

	# Function to insert a node into the heap
	def insert(self, element):
		#We only consider b_time for sorting.
                #Need not worry about r_time
		self.size += 1
		self.Heap.insert(self.size, element)

		current = self.size

		while (self.Heap[current].b_time >
			self.Heap[self.parent(current)].b_time):
			self.swap(current, self.parent(current))
			current = self.parent(current)
		if self.size > self.maxsize:
                        self.maxsize = self.size

	# Function to print the contents of the heap
	def Print(self):
		print("<Position> : (b_time, r_time)")
		for i in range(1, (self.size // 2) + 1):
                        if (i<=self.size):
                                print(" PARENT : (" + str(self.Heap[i].b_time) + ", " + str(self.Heap[i].r_time), end=")\t")
                        if (2*i <= self.size):
                                print(" LEFT CHILD : (" + str(self.Heap[2 * i].b_time) + ", " + str(self.Heap[2 * i].r_time), end=")\t")
                        if((2*i + 1) <= self.size):
                                print(" RIGHT CHILD : (" + str(self.Heap[2 * i + 1].b_time) + ", " + str(self.Heap[2 * i + 1].r_time) + ")")

	# Function to remove and return the maximum
	# element from the heap
	#def extractMin(self):
		#popped = self.Heap[self.FRONT]
		#self.Heap[self.FRONT] = self.Heap[self.size]
		#self.size -= 1
		#self.minHeapify(self.FRONT)
		#return popped
	def extractMax(self):
		popped = self.Heap[self.FRONT]
		self.Heap[self.FRONT] = self.Heap[self.size]
		self.size -= 1
		#self.minHeapify(self.FRONT)
		self.build_max_heap()
		#print(popped)
		return popped
#_________________________________________--xxx--_____________________________________________
class reqMinHeap:

	def __init__(self, maxsize):
		self.maxsize = maxsize
		self.size = 0   #1 because the first entry is already put to 1(ignore)
		self.Heap = []  #Initialize empty array instead#[Entry(0,0)] * (self.maxsize + 1)
		self.Heap.append(-1*sys.maxsize)
		self.FRONT = 1

	# Function to return the position of
	# parent for the node currently
	# at pos
	def parent(self, pos):

		return pos // 2

	# Function to return the position of
	# the left child for the node currently
	# at pos
	def leftChild(self, pos):

		return 2 * pos

	# Function to return the position of
	# the right child for the node currently
	# at pos
	def rightChild(self, pos):

		return (2 * pos) + 1

	# Function that returns true if the passed
	# node is a leaf node
	def isLeaf(self, pos):

		if pos >= (self.size//2) and pos <= self.size:
			return True
		return False

	# Function to swap two nodes of the heap
	def swap(self, fpos, spos):

		self.Heap[fpos], self.Heap[spos] = (self.Heap[spos],
											self.Heap[fpos])

	# Function to heapify the node at pos (motivation from DSA slides)
	def minHeapify(self, pos):
                smallest = pos
                if (self.leftChild(pos) < self.size and self.Heap[self.leftChild(pos)] < self.Heap[pos]):
                        smallest = self.leftChild(pos)
                if (self.rightChild(pos) < self.size and self.Heap[self.rightChild(pos)] < self.Heap[smallest]):
                        smallest = self.rightChild(pos)
                if smallest != pos:
                        self.Heap[pos], self.Heap[smallest] = self.Heap[smallest], self.Heap[pos]
                        self.minHeapify(smallest)

	def build_min_heap(self):
		for i in reversed(range(1, (self.size//2) + 1)):
			self.minHeapify(i)
			
	# Function to insert a node into the heap
	def insert(self, element):
		#We only consider b_time for sorting.
                #Need not worry about r_time
		self.size += 1
		self.Heap.insert(self.size, element)
		#self.Heap[self.size] = (element)

		current = self.size

		while (self.Heap[current] <
			self.Heap[self.parent(current)]):
			self.swap(current, self.parent(current))
			current = self.parent(current)
		self.build_min_heap()
		if self.size > self.maxsize:
                        self.maxsize = self.size
		#self.Heap.Print()

	# Function to print the contents of the heap
	def Print(self):
		print("<Position> : (b_time, r_time)")
		for i in range(1, (self.size // 2) + 1):
                        if (i<=self.size):
                                print(" PARENT : (" + str(self.Heap[i]) + ")", end="\t")
                        if (2*i <= self.size):
                                print(" LEFT CHILD : (" + str(self.Heap[2 * i]) + ")", end="\t")
                        if((2*i + 1) <= self.size):
                                print(" RIGHT CHILD : (" + str(self.Heap[2 * i + 1]) + ")\t")
                        print('')
	# Function to remove and return the maximum
	# element from the heap
	#def extractMin(self):
		#popped = self.Heap[self.FRONT]
		#self.Heap[self.FRONT] = self.Heap[self.size]
		#self.size -= 1
		#self.minHeapify(self.FRONT)
		#return popped
	def extractMin(self):
		popped = self.Heap[self.FRONT]
		self.Heap[self.FRONT] = self.Heap[self.size]
		self.size -= 1
		#self.minHeapify(self.FRONT)
		self.build_min_heap()
		#print(popped)
		return popped
#______________________---xxx---_________________________________________

# Function to read input file from user
def read_input(input_file):
	try:
		with open(input_file,"r+") as file:
			lines = file.readlines()
		return lines
	except:
		sys.exit("Could not read input file. Please check")

# Function to convert input time
# intervals to separate lists of
# borrowal and return times
def convert_input(lines):
	#bor_t = []
	#ret_t = []
        heap = MaxHeap(len(lines))  #in Lines, there is one extra line which covers the Heap[0] case
        for l in lines:
                if(l.find(",") != -1):
                        heap.Heap.append(Entry(int(l.split(",")[0]), int(l.split(",")[-1])))
                        heap.size +=1
                        current = heap.size
                        while (heap.Heap[current].b_time >= heap.Heap[heap.parent(current)].b_time):
                                if (heap.Heap[current].b_time > heap.Heap[heap.parent(current)].b_time):
                                        heap.swap(current, heap.parent(current))
                                        current = heap.parent(current)
                                elif(heap.Heap[current].b_time == heap.Heap[heap.parent(current)].b_time):
                                        if(heap.Heap[current].r_time > heap.Heap[heap.parent(current)].r_time):
                                                heap.swap(current, heap.parent(current))
                                                current = heap.parent(current)
                                        else:
                                                break
                                else:
                                        break
                heap.Print()
      #heap.Print()
      #print(heap.Heap)
        print("________________")
        return heap

# Function to dump code output to a file
def create_output(file_name, output):
	try:
		with open(file_name, "w+") as file:
			file.write("Minimum laptops required: " + str(output))
			file.close()
		print("Minimum laptops required: " + str(output))
	except:
		sys.exit("The output file could not be created")

# Function to create max-heap from
# input array
def create_heap(arr, size):

	min_heap = MinHeap(n_students)

	for i in range(0, size):
		min_heap.insert(arr[i])
	min_heap.Print()
	#min_heap.Print()
	return min_heap

# Function which calls Heap Sort algorithm
# on the created max-heap
def heap_sort(heap, size):
	sorted_heap = []

	for i in range(0, size):
		sorted_heap.insert(0, heap.extractMin())
		# Note: The above insert() is python in-built
		# function and not our class function
	return sorted_heap

# Core function which returns minimum
# laptops required to be rented
def laptop_req(sorted_b_time):
        req_laptop_heap = reqMinHeap(0)
        req_laptop_heap.insert(0)       #initialize min heap with zero
        for entry in sorted_b_time:
                if(entry.b_time < req_laptop_heap.Heap[req_laptop_heap.FRONT]):
                        #If borrow time of incoming person is less than root of min heap, it means we will need another resource (Laptop)
                        #Hence, pop nothing, we will insert current person's return time as well
                        req_laptop_heap.insert(entry.r_time)
                elif(entry.b_time >= req_laptop_heap.Heap[req_laptop_heap.FRONT]):
                        #If borrow time is more than root of min heap of return times, it means ther will be one laptop which will be returned before this person borrow's it
                        #We extract this from min heap as this laptop can be used. We also insert the return time  of this user just like above
                        req_laptop_heap.extractMin()
                        req_laptop_heap.insert(entry.r_time)
                req_laptop_heap.Print()
        return req_laptop_heap.maxsize

# Driver Code
if __name__ == "__main__":
        heap = convert_input(read_input("DSAD_input.txt"))
        #heap.Print()
        heap.build_max_heap()
        sorted_heap = []
        for i in range(0, heap.size):
                sorted_heap.append(heap.extractMax())
        sorted_heap.reverse()
        for entry in sorted_heap:
                print(entry.b_time,  entry.r_time)
        print("Minimum number of laptops required = " + str(laptop_req(sorted_heap)))
